<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Traffic Lights</title>

    <!-- Add support for Web Components to older browsers. -->
    <script src="./node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>

    <!-- Your application must load the Roboto and Material Icons fonts. -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Material+Icons&display=block" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', 'Arial', 'Helvetica', sans-serif;
        }

        .container {
            margin: 0 auto;
            margin-top: 8%;
            width: 80%;
        }

        mwc-textfield.field {
            width: 100%;
            display: block;
            margin-bottom: 40px;
        }

        mwc-textfield.red {
            --mdc-theme-primary: firebrick;
            --mdc-text-field-outlined-idle-border-color: firebrick;
        }
        mwc-textfield.yellow {
            --mdc-theme-primary: gold;
            --mdc-text-field-outlined-idle-border-color: gold;
        }
        mwc-textfield.yellow-red {
            --mdc-theme-primary: orange;
            --mdc-text-field-outlined-idle-border-color: orange;
        }
        mwc-textfield.green {
            --mdc-theme-primary: green;
            --mdc-text-field-outlined-idle-border-color: green;
        }
        #button {
            display: flex;
            justify-content: center;
        }
        .sliderContainer {
            justify-content: center;
            margin-bottom: 40px;
        }
        #onSlider {
            --mdc-theme-secondary: blue;
        }
        p {
            font-size: large;
        }
        #stateFooter {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            color: white;
            text-align: center;
            visibility: hidden;
        }
        .offline {
            background-color: firebrick;
        }
        .online {
            background-color: forestgreen;
        }

    </style>
  </head>
  <body>
      <div class="container">
        <h1>Traffic Lights Controller</h1>
        <div class="sliderContainer">
            <p>On/Off</p>
            <mwc-switch id="onSlider"></mwc-switch>
        </div>
        <mwc-textfield id="greenDuration" class="green field fixed" label="Green duration" type="number" suffix="s" placeholder="60" outlined>
        </mwc-textfield>
        <mwc-textfield id="yellowDuration" class="yellow field fixed" label="Yellow duration" type="number" suffix="s" placeholder="60" outlined>
        </mwc-textfield>
        <mwc-textfield id="yellowRedDuration" class="yellow-red field fixed" label="Red-Yellow duration" type="number" suffix="s" placeholder="60" outlined>
        </mwc-textfield>
        <mwc-textfield id="redLower" class="red field interval" label="Min. Red duration" type="number" suffix="s" placeholder="60" outlined></mwc-textfield>
        <mwc-textfield id="redUpper" class="red field interval" label="Max. Red duration" type="number" suffix="s" placeholder="60" outlined></mwc-textfield>
        <mwc-button id="button" label="Update" raised></mwc-button>
        <mwc-snackbar id="event-toast" labelText="" timeoutMs="4000">
            <mwc-icon-button icon="close" slot="dismiss"></mwc-icon-button>
        </mwc-snackbar>
        <div id="stateFooter" class="offline" >Offline</div>
      </div>
    <script type="module">
      import '@material/mwc-button';
      import '@material/mwc-icon-button';
      import '@material/mwc-textfield';
      import '@material/mwc-switch';
      import '@material/mwc-snackbar';

      // server config
      const HOSTNAME = "localhost";
      const PORT = "8080";
      const URL = `http://${HOSTNAME}:${PORT}`;

      // errors
      const UPDATE_FAILED = "Updating the traffic lights configuration failed.";
      const ON_OFF_FAILED = "Turning the traffic lights on or off failed.";
      const NO_CONNECTION_ERROR = "Cannot connect to the traffic lights controller.";
      const UNEXPECTEND_ERROR_WHILE_START_OR_STOP = "An unexpected error occurred while starting or stopping the traffic lights controller.";
      const UNEXPECTED_ERROR_WHILE_UPDATING = "An unexpected error occurred while updating the traffic lights configuration."

      var currentStateOnline;
      var syncInterval;

      // elements
      const onSilder = document.querySelector('#onSlider');

      const greenDurationField = document.querySelector('#greenDuration');
      const yellowDurationField = document.querySelector('#yellowDuration');
      const yellowRedDurationField = document.querySelector('#yellowRedDuration');
      const minRedDurationField = document.querySelector('#redLower');
      const maxRedDurationField = document.querySelector('#redUpper');

      const fields = document.querySelectorAll('.field');
      const fixeds = document.querySelectorAll('.fixed');
      const intervals = document.querySelectorAll('.interval');

      const eventToast = document.querySelector('#event-toast');
      const stateFooter = document.querySelector('#stateFooter');

      // check if controller is alive
      const isAlive = () => new Promise(resolve => fetch(`${URL}/heartbeat`).then(res => {
              resolve(res.ok);
          }).catch(err => {
              resolve(false);
          }));
      

      // state handling
      const changeState = isOnline => {
        if(currentStateOnline == isOnline) {
            return;
        }

        if(isOnline == true) {
            stateFooter.innerHTML = 'online';
            stateFooter.classList = ['online'];
            stateFooter.style.visibility = 'visible';
            currentStateOnline = true;
            new Promise(resolve => {
                setTimeout(resolve, 7000);
            }).then(() => stateFooter.style.visibility = 'hidden');
        } else {
            stateFooter.innerHTML = "offline";
            stateFooter.classList = ['offline'];
            stateFooter.style.visibility = 'visible';

            currentStateOnline = false;
            syncInterval = setInterval(() => {
                isAlive().then(res => {
                    console.log(`Sync result: ${res}`);
                    if (res) {
                        clearInterval(syncInterval);
                        changeState(true);
                    }
                })
            }, 5000);
        }
      }

      // fetches config data
      const fetchCurrentData = () => fetch(`${URL}/config`).then(data => { 
          return data.json();
      }).catch(err => {
          reportError(NO_CONNECTION_ERROR);
      }).then(json => {
          greenDurationField.value = json.greenLightDuration;
          yellowDurationField.value = json.yellowLightDuration;
          yellowRedDurationField.value = json.yellowRedLightDuration;
          minRedDurationField.value = json.lowerIntervalBorder;
          maxRedDurationField.value = json.upperIntervalBorder;
          reportSuccess("Loaded current traffic lights configuration.");
      });

      // fetches state running/paused
      const fetchCurrentControllerState = () => fetch(`${URL}/config`).then(res => {
        if(res.status === 200) {
            onSilder.checked = true;
        } else if (res.status === 204) {
            onSilder.checked = false;
        }
      });

      // determines initial state
      isAlive().then(result => {
          changeState(result);
          fetchCurrentData();
          fetchCurrentControllerState();
      });

      // validity
      const biggerThanZeroConstraint = (newValue, nativeValidity) => {
          if (!nativeValidity.valid) {
              return {};
          }

          const isValid = (newValue > 0 || newValue == "")
          console.log(`Is valid: ${isValid}`)
          return {
              valid: isValid,
              customError: !isValid
          };
      }

      const validInterval = (newValue, nativeValidity, currentElement) => {
          if (!nativeValidity.valid) {
              return {};
          }

          const isValid = (newValue > 0 || newValue == "")  && parseInt(minRedDurationField.value) < parseInt(maxRedDurationField.value);
          console.log(`Is valid: ${isValid}`);

          return {
              valid: isValid,
              customError: !isValid
          };
      }

      fixeds.forEach(element => {
          element.validityTransform = biggerThanZeroConstraint 
      });

      minRedDurationField.addEventListener('change', () => maxRedDurationField.checkValidity());
      maxRedDurationField.addEventListener('change', () => minRedDurationField.checkValidity());
      
      intervals.forEach(element => {
          element.validityTransform = (newValue, nativeValidity) => validInterval(newValue, nativeValidity, element);
      });

      // reporting errors
      const reportError = error => {
          eventToast.labelText = error;
          eventToast.show();
          if (NO_CONNECTION_ERROR) {
            changeState(false);
          }
      }

      // report validation errors
      const reportInvalidFields = () => {
          const invalidFieldMessages = [... fields].filter(field => !field.valid).map(field => `${field.label}: "${field.value}"\n`);
          let validationReport = 'The following fields are invalid: ';
          invalidFieldMessages.forEach(message => {
            if (message != invalidFieldMessages[0]) {
                validationReport += ', ';
              }
            validationReport += message;
          });
          eventToast.labelText = validationReport;
          eventToast.show();
      }

      // reporting successes
      const reportSuccess = message => {
          eventToast.labelText = message;
          eventToast.show();
          changeState(true);
      }

      // fetching
      const inputDataToJSON = () => {
        return {
            lowerIntervalBorder: minRedDurationField.value,
            upperIntervalBorder: maxRedDurationField.value,
            greenLightDuration: greenDurationField.value,
            yellowLightDuration: yellowDurationField.value,
            yellowRedLightDuration: yellowRedDurationField.value
        }
      }

      // updating server config
      const updateServerData = () => {
          const allValid = [... fields].reduce((x,y) => x && y.checkValidity(), fields, true);
          if (!allValid) {
              reportInvalidFields();
              console.log("Some fields seem to be invalid.");
              return;
          }

          const handleStartStopFetchPromise = (prom, operation) => {
              prom.then(res => {
                  if(res && !res.ok && res.status === 500) {
                    throw ON_OFF_FAILED;
                  } else if(res && !res.ok) {
                    throw UNEXPECTEND_ERROR_WHILE_START_OR_STOP;
                  } else if(!res) {
                    throw NO_CONNECTION_ERROR;
                  }
                  if (res.status == 204) {
                      reportSuccess('Successfully updated the traffic lights configuration.');
                      return;
                  }
                  reportSuccess(`Successfully updated the configuration and ${operation}ed the traffic lights.`);
              }).catch(err => {
                  switch (err) {
                      case ON_OFF_FAILED:
                        reportError(ON_OFF_FAILED);
                        break;

                      case UNEXPECTEND_ERROR_WHILE_START_OR_STOP:
                        reportError(UNEXPECTEND_ERROR_WHILE_START_OR_STOP);
                        break;
                  
                      default:
                        reportError(NO_CONNECTION_ERROR);
                        break;
                  }
              })
          }

          const data = inputDataToJSON();
          const res = fetch(`${URL}/config`, {
              method: 'POST',
              body: JSON.stringify(data)
            }).catch(err => reportError(NO_CONNECTION_ERROR)).then(res => {
                if (res && !res.ok) {
                    throw UPDATE_FAILED;
                } else if(!res) {
                    throw NO_CONNECTION_ERROR;
                }

                if (onSilder.checked) {
                    const startPromise = fetch(`${URL}/start`);
                    handleStartStopFetchPromise(startPromise, 'start');
                } else { 
                    const startPromise = fetch(`${URL}/stop`);
                    handleStartStopFetchPromise(startPromise, 'stop');
                }
            }).catch(err => { 
                switch (err) {
                    case UPDATE_FAILED:
                        reportError(err);
                        break;

                    case NO_CONNECTION_ERROR:
                        reportError(err);
                        break;
                
                    default:
                        reportError(UNEXPECTED_ERROR_WHILE_UPDATING);
                        break;
                }
            });
      }

      const button = document.querySelector('#button');
      button.addEventListener('click', () => {
        updateServerData()
      });
    </script>
  </body>
</html>